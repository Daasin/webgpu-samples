_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[20],{"7r7F":function(e,n,t){"use strict";t.r(n),t.d(n,"geometryVertexArray",(function(){return P}));var r,a,o=t("o0o1"),i=t.n(o),s=t("HaE+"),d=t("rePB"),u=t("IOcx"),c=t("SoUo");function p(e,n){var t;if("undefined"===typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(t=function(e,n){if(!e)return;if("string"===typeof e)return f(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);"Object"===t&&e.constructor&&(t=e.constructor.name);if("Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return f(e,n)}(e))||n&&e&&"number"===typeof e.length){t&&(e=t);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,i=!0,s=!1;return{s:function(){t=e[Symbol.iterator]()},n:function(){var e=t.next();return i=e.done,e},e:function(e){s=!0,o=e},f:function(){try{i||null==t.return||t.return()}finally{if(s)throw o}}}}function f(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,r=new Array(n);t<n;t++)r[t]=e[t];return r}var l,m=32,h=12,v=1e-4,P=new Float32Array([-1.5,-1,v,1,1,0,0,1,.5,-1,v,1,1,0,0,1,-1.5,1,v,1,1,0,0,1,.5,-1,v,1,1,0,0,1,.5,1,v,1,1,0,0,1,-1.5,1,v,1,1,0,0,1,-.5,-1,-v,1,0,1,0,1,1.5,-1,-v,1,0,1,0,1,-.5,1,-v,1,0,1,0,1,1.5,-1,-v,1,0,1,0,1,1.5,1,-v,1,0,1,0,1,-.5,1,-v,1,0,1,0,1]),g=c.b/2,x=u.a.create();function b(e,n,t,r,a){var o=1/Math.tan(n/2);if(e[0]=o/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=a&&a!==1/0){var i=1/(r-a);e[10]=a*i,e[14]=a*r*i}else e[10]=-1,e[14]=-r;return e}x[10]=-1,x[14]=1,function(e){e[e.Default=0]="Default",e[e.Reversed=1]="Reversed"}(l||(l={}));var w=[l.Default,l.Reversed],y=(r={},Object(d.a)(r,l.Default,"less"),Object(d.a)(r,l.Reversed,"greater"),r),D=(a={},Object(d.a)(a,l.Default,1),Object(d.a)(a,l.Reversed,0),a);function M(){return(M=Object(s.a)(i.a.mark((function e(n,t){var r,a,o,s,d,f,v,M,S,V,R,C,T,U,G,A,O,E,L,F,k,I,_,z,j,Q,N,q,W,H,$,Z,X,Y,J,K,ee,ne,te,re,ae,oe;return i.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return ae=function(){for(var e=Date.now()/1e3,n=0,t=0;n<5;n++,t+=16)u.a.rotate(re,N[n],Math.PI/180*30,u.b.fromValues(Math.sin(e),Math.cos(e),0)),q.set(re,t)},e.next=3,navigator.gpu.requestAdapter();case 3:return r=e.sent,e.next=6,r.requestDevice();case 6:for(a=e.sent,o=n.getContext("gpupresent"),s=o.configureSwapChain({device:a,format:"bgra8unorm"}),d=a.createBuffer({size:P.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(d.getMappedRange()).set(P),d.unmap(),f="depth32float",v={vertex:{module:a.createShaderModule({code:B.vertexDepthPrePass}),entryPoint:"main",buffers:[{arrayStride:m,attributes:[{shaderLocation:0,offset:0,format:"float32x4"}]}]},fragment:{module:a.createShaderModule({code:B.fragmentDepthPrePass}),entryPoint:"main",targets:[]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:f}},M=[],v.depthStencil.depthCompare=y[l.Default],M[l.Default]=a.createRenderPipeline(v),v.depthStencil.depthCompare=y[l.Reversed],M[l.Reversed]=a.createRenderPipeline(v),S={vertex:{module:a.createShaderModule({code:B.vertexPrecisionErrorPass}),entryPoint:"main",buffers:[{arrayStride:m,attributes:[{shaderLocation:0,offset:0,format:"float32x4"}]}]},fragment:{module:a.createShaderModule({code:B.fragmentPrecisionErrorPass}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:f}},V=[],S.depthStencil.depthCompare=y[l.Default],V[l.Default]=a.createRenderPipeline(S),S.depthStencil.depthCompare=y[l.Reversed],V[l.Reversed]=a.createRenderPipeline(S),R={vertex:{module:a.createShaderModule({code:B.vertex}),entryPoint:"main",buffers:[{arrayStride:m,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x4"}]}]},fragment:{module:a.createShaderModule({code:B.fragment}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:f}},C=[],R.depthStencil.depthCompare=y[l.Default],C[l.Default]=a.createRenderPipeline(R),R.depthStencil.depthCompare=y[l.Reversed],C[l.Reversed]=a.createRenderPipeline(R),T=a.createRenderPipeline({vertex:{module:a.createShaderModule({code:B.vertexTextureQuad}),entryPoint:"main"},fragment:{module:a.createShaderModule({code:B.fragmentTextureQuad}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),U=a.createTexture({size:{width:n.width,height:n.height},format:f,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.SAMPLED}),G=U.createView(),A=a.createTexture({size:{width:n.width,height:n.height},format:f,usage:GPUTextureUsage.RENDER_ATTACHMENT}),O=A.createView(),E={colorAttachments:[],depthStencilAttachment:{view:G,depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},L=[{colorAttachments:[{view:void 0,loadValue:{r:0,g:0,b:.5,a:1},storeOp:"store"}],depthStencilAttachment:{view:O,depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},{colorAttachments:[{view:void 0,loadValue:"load",storeOp:"store"}],depthStencilAttachment:{view:O,depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}}],F=[{colorAttachments:[{view:void 0,loadValue:{r:0,g:0,b:.5,a:1},storeOp:"store"}]},{colorAttachments:[{view:void 0,loadValue:"load",storeOp:"store"}]}],k=a.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]}),I=a.createBindGroup({layout:k,entries:[{binding:0,resource:G},{binding:1,resource:a.createSampler()}]}),320,_=a.createBuffer({size:320,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),z=a.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),j=a.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),Q=[a.createBindGroup({layout:M[l.Default].getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:_}},{binding:1,resource:{buffer:z}}]}),a.createBindGroup({layout:M[l.Reversed].getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:_}},{binding:1,resource:{buffer:j}}]})],N=new Array(5),q=new Float32Array(80),W=0,H=0;H<1;H++)for($=0;$<5;$++)Z=-800*W,X=1+50*W,N[W]=u.a.create(),u.a.translate(N[W],N[W],u.b.fromValues(H-.5+.5,(4-.2*Z)*($-2.5+1),Z)),u.a.scale(N[W],N[W],u.b.fromValues(X,X,X)),W++;return Y=u.a.create(),u.a.translate(Y,Y,u.b.fromValues(0,0,-12)),J=.5*Math.abs(n.width/n.height),b(K=u.a.create(),2*Math.PI/5,J,5,1/0),ee=u.a.create(),u.a.multiply(ee,K,Y),ne=u.a.create(),u.a.multiply(ne,x,ee),te=ee,a.queue.writeBuffer(z,0,te.buffer,te.byteOffset,te.byteLength),te=ne,a.queue.writeBuffer(j,0,te.buffer,te.byteOffset,te.byteLength),re=u.a.create(),oe={mode:"color"},t.add(oe,"mode",["color","precision-error","depth-texture"]),e.abrupt("return",(function(){ae(),a.queue.writeBuffer(_,0,q.buffer,q.byteOffset,q.byteLength);var e=s.getCurrentTexture().createView(),n=a.createCommandEncoder();if("color"===oe.mode){var t,r=p(w);try{for(r.s();!(t=r.n()).done;){var o=t.value;L[o].colorAttachments[0].view=e,L[o].depthStencilAttachment.depthLoadValue=D[o];var i=n.beginRenderPass(L[o]);i.setPipeline(C[o]),i.setBindGroup(0,Q[o]),i.setVertexBuffer(0,d),i.setViewport(g*o,0,g,c.a,0,1),i.draw(h,5,0,0),i.endPass()}}catch(S){r.e(S)}finally{r.f()}}else if("precision-error"===oe.mode){var u,f=p(w);try{for(f.s();!(u=f.n()).done;){var l=u.value;E.depthStencilAttachment.depthLoadValue=D[l];var m=n.beginRenderPass(E);m.setPipeline(M[l]),m.setBindGroup(0,Q[l]),m.setVertexBuffer(0,d),m.setViewport(g*l,0,g,c.a,0,1),m.draw(h,5,0,0),m.endPass(),L[l].colorAttachments[0].view=e,L[l].depthStencilAttachment.depthLoadValue=D[l];var v=n.beginRenderPass(L[l]);v.setPipeline(V[l]),v.setBindGroup(0,Q[l]),v.setBindGroup(1,I),v.setVertexBuffer(0,d),v.setViewport(g*l,0,g,c.a,0,1),v.draw(h,5,0,0),v.endPass()}}catch(S){f.e(S)}finally{f.f()}}else{var P,x=p(w);try{for(x.s();!(P=x.n()).done;){var b=P.value;E.depthStencilAttachment.depthLoadValue=D[b];var y=n.beginRenderPass(E);y.setPipeline(M[b]),y.setBindGroup(0,Q[b]),y.setVertexBuffer(0,d),y.setViewport(g*b,0,g,c.a,0,1),y.draw(h,5,0,0),y.endPass(),F[b].colorAttachments[0].view=e;var B=n.beginRenderPass(F[b]);B.setPipeline(T),B.setBindGroup(0,I),B.setViewport(g*b,0,g,c.a,0,1),B.draw(6,1,0,0),B.endPass()}}catch(S){x.e(S)}finally{x.f()}}a.queue.submit([n.finish()])}));case 71:case"end":return e.stop()}}),e)})))).apply(this,arguments)}var B={vertex:"\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(".concat(64,")]] array<mat4x4<f32>, ").concat(5,">;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] fragColor : vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] instanceIdx : u32,\n        [[location(0)]] position : vec4<f32>,\n        [[location(1)]] color : vec4<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  output.fragColor = color;\n  return output;\n}\n"),fragment:"\n[[stage(fragment)]]\nfn main([[location(0)]] fragColor : vec4<f32>) -> [[location(0)]] vec4<f32> {\n  return fragColor;\n}\n",vertexDepthPrePass:"\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(".concat(64,")]] array<mat4x4<f32>, ").concat(5,">;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] instanceIdx : u32,\n        [[location(0)]] position : vec4<f32>)\n     -> [[builtin(position)]] vec4<f32> {\n  return camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n}\n"),fragmentDepthPrePass:"\n[[stage(fragment)]]\nfn main() {\n}\n",vertexPrecisionErrorPass:"\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(".concat(64,")]] array<mat4x4<f32>, ").concat(5,">;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] clipPos : vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] instanceIdx : u32,\n        [[location(0)]] position : vec4<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  output.clipPos = output.Position;\n  return output;\n}\n"),fragmentPrecisionErrorPass:"\n[[group(1), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(1), binding(1)]] var depthSampler: sampler;\n\n[[stage(fragment)]]\nfn main([[builtin(position)]] coord : vec4<f32>,\n        [[location(0)]] clipPos : vec4<f32>)\n     -> [[location(0)]] vec4<f32> {\n  let depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(".concat(c.b.toFixed(1),", ").concat(c.a.toFixed(1),")).r;\n  let v : f32 = abs(clipPos.z / clipPos.w - depthValue) * 2000000.0;\n  return vec4<f32>(v, v, v, 1.0) ;\n}\n"),vertexTextureQuad:"\nlet pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n  vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0), vec2<f32>(-1.0, 1.0),\n  vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, -1.0), vec2<f32>(1.0, 1.0));\n\n[[stage(vertex)]]\nfn main([[builtin(vertex_index)]] VertexIndex : u32)\n     -> [[builtin(position)]] vec4<f32> {\n  return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n}\n",fragmentTextureQuad:"\n[[group(0), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var depthSampler: sampler;\n\n[[stage(fragment)]]\nfn main([[builtin(position)]] coord : vec4<f32>)\n     -> [[location(0)]] vec4<f32> {\n  let depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(".concat(c.b.toFixed(1),", ").concat(c.a.toFixed(1),")).r;\n  return vec4<f32>(depthValue, depthValue, depthValue, 1.0);\n}\n")};n.default=Object(c.c)({name:"Reversed Z",description:"This example shows the use of reversed z technique for better utilization of depth buffer precision.\n    The left column uses regular method, while the right one uses reversed z technique.\n    Both are using depth32float as their depth buffer format. A set of red and green planes are positioned very close to each other.\n    Higher sets are placed further from camera (and are scaled for better visual purpose).\n    To use reversed z to render your scene, you will need depth store value to be 0.0, depth compare function to be greater,\n    and remap depth range by multiplying an additional matrix to your projection matrix.\n    Related reading:\n    https://developer.nvidia.com/content/depth-precision-visualized\n    https://thxforthefish.com/posts/reverse_z/\n    ",slug:"reversedZ",init:function(e,n){return M.apply(this,arguments)},source:"import { mat4, vec3 } from 'gl-matrix';\nimport type { GUI } from 'dat.gui';\nimport {\n  kDefaultCanvasWidth,\n  kDefaultCanvasHeight,\n  makeBasicExample,\n} from '../../components/basicExample';\n\n// Two planes close to each other for depth precision test\nconst geometryVertexSize = 4 * 8; // Byte size of one geometry vertex.\nconst geometryPositionOffset = 0;\nconst geometryColorOffset = 4 * 4; // Byte offset of geometry vertex color attribute.\nconst geometryDrawCount = 6 * 2;\n\nconst d = 0.0001; // half distance between two planes\nconst o = 0.5; // half x offset to shift planes so they are only partially overlaping\n\n// prettier-ignore\nexport const geometryVertexArray = new Float32Array([\n  // float4 position, float4 color\n  -1 - o, -1, d, 1, 1, 0, 0, 1,\n   1 - o, -1, d, 1,  1, 0, 0, 1,\n  -1 - o, 1, d, 1,  1, 0, 0, 1,\n   1 - o, -1,  d, 1, 1, 0, 0, 1,\n   1 - o, 1,  d, 1,  1, 0, 0, 1,\n  -1 - o, 1, d, 1,  1, 0, 0, 1,\n\n  -1 + o, -1, -d, 1, 0, 1, 0, 1,\n   1 + o, -1, -d, 1,  0, 1, 0, 1,\n  -1 + o, 1, -d, 1,  0, 1, 0, 1,\n   1 + o, -1,  -d, 1, 0, 1, 0, 1,\n   1 + o, 1,  -d, 1,  0, 1, 0, 1,\n  -1 + o, 1, -d, 1,  0, 1, 0, 1,\n]);\n\nconst kViewportWidth = kDefaultCanvasWidth / 2;\n\nconst xCount = 1;\nconst yCount = 5;\nconst numInstances = xCount * yCount;\nconst matrixFloatCount = 16; // 4x4 matrix\nconst matrixStride = 4 * matrixFloatCount;\n\nconst depthRangeRemapMatrix = mat4.create();\ndepthRangeRemapMatrix[10] = -1;\ndepthRangeRemapMatrix[14] = 1;\n\n// https://github.com/toji/gl-matrix/commit/e906eb7bb02822a81b1d197c6b5b33563c0403c0\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  const f = 1.0 / Math.tan(fovy / 2);\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    const nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n  return out;\n}\n\nenum DepthBufferMode {\n  Default = 0,\n  Reversed,\n}\n\nconst depthBufferModes: DepthBufferMode[] = [\n  DepthBufferMode.Default,\n  DepthBufferMode.Reversed,\n];\nconst depthCompareFuncs = {\n  [DepthBufferMode.Default]: 'less' as GPUCompareFunction,\n  [DepthBufferMode.Reversed]: 'greater' as GPUCompareFunction,\n};\nconst depthLoadValues = {\n  [DepthBufferMode.Default]: 1.0,\n  [DepthBufferMode.Reversed]: 0.0,\n};\n\nasync function init(canvas: HTMLCanvasElement, gui?: GUI) {\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n\n  const context = canvas.getContext('gpupresent');\n\n  const swapChain = context.configureSwapChain({\n    device,\n    format: 'bgra8unorm',\n  });\n\n  const verticesBuffer = device.createBuffer({\n    size: geometryVertexArray.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  new Float32Array(verticesBuffer.getMappedRange()).set(geometryVertexArray);\n  verticesBuffer.unmap();\n\n  const depthBufferFormat = 'depth32float';\n\n  // depthPrePass is used to render scene to the depth texture\n  // this is not needed if you just want to use reversed z to render a scene\n  const depthPrePassRenderPipelineDescriptorBase: GPURenderPipelineDescriptor = {\n    vertex: {\n      module: device.createShaderModule({\n        code: wgslShaders.vertexDepthPrePass,\n      }),\n      entryPoint: 'main',\n      buffers: [\n        {\n          arrayStride: geometryVertexSize,\n          attributes: [\n            {\n              // position\n              shaderLocation: 0,\n              offset: geometryPositionOffset,\n              format: 'float32x4',\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: wgslShaders.fragmentDepthPrePass,\n      }),\n      entryPoint: 'main',\n      targets: [],\n    },\n    primitive: {\n      topology: 'triangle-list',\n      cullMode: 'back',\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: depthBufferFormat,\n    },\n  };\n  // we need the depthCompare to fit the depth buffer mode we are using.\n  // this is the same for other passes\n  const depthPrePassPipelines: GPURenderPipeline[] = [];\n  depthPrePassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Default];\n  depthPrePassPipelines[DepthBufferMode.Default] = device.createRenderPipeline(\n    depthPrePassRenderPipelineDescriptorBase\n  );\n  depthPrePassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Reversed];\n  depthPrePassPipelines[DepthBufferMode.Reversed] = device.createRenderPipeline(\n    depthPrePassRenderPipelineDescriptorBase\n  );\n\n  // precisionPass is to draw precision error as color of depth value stored in depth buffer\n  // compared to that directly calcualated in the shader\n  const precisionPassRenderPipelineDescriptorBase: GPURenderPipelineDescriptor = {\n    vertex: {\n      module: device.createShaderModule({\n        code: wgslShaders.vertexPrecisionErrorPass,\n      }),\n      entryPoint: 'main',\n      buffers: [\n        {\n          arrayStride: geometryVertexSize,\n          attributes: [\n            {\n              // position\n              shaderLocation: 0,\n              offset: geometryPositionOffset,\n              format: 'float32x4',\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: wgslShaders.fragmentPrecisionErrorPass,\n      }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: 'bgra8unorm',\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n      cullMode: 'back',\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: depthBufferFormat,\n    },\n  };\n  const precisionPassPipelines: GPURenderPipeline[] = [];\n  precisionPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Default];\n  precisionPassPipelines[DepthBufferMode.Default] = device.createRenderPipeline(\n    precisionPassRenderPipelineDescriptorBase\n  );\n  precisionPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Reversed];\n  precisionPassPipelines[\n    DepthBufferMode.Reversed\n  ] = device.createRenderPipeline(precisionPassRenderPipelineDescriptorBase);\n\n  // colorPass is the regular render pass to render the scene\n  const colorPassRenderPipelineDescriptorBase: GPURenderPipelineDescriptor = {\n    vertex: {\n      module: device.createShaderModule({\n        code: wgslShaders.vertex,\n      }),\n      entryPoint: 'main',\n      buffers: [\n        {\n          arrayStride: geometryVertexSize,\n          attributes: [\n            {\n              // position\n              shaderLocation: 0,\n              offset: geometryPositionOffset,\n              format: 'float32x4',\n            },\n            {\n              // color\n              shaderLocation: 1,\n              offset: geometryColorOffset,\n              format: 'float32x4',\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: wgslShaders.fragment,\n      }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: 'bgra8unorm',\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n      cullMode: 'back',\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: depthBufferFormat,\n    },\n  };\n  const colorPassPipelines: GPURenderPipeline[] = [];\n  colorPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Default];\n  colorPassPipelines[DepthBufferMode.Default] = device.createRenderPipeline(\n    colorPassRenderPipelineDescriptorBase\n  );\n  colorPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Reversed];\n  colorPassPipelines[DepthBufferMode.Reversed] = device.createRenderPipeline(\n    colorPassRenderPipelineDescriptorBase\n  );\n\n  // textureQuadPass is draw a full screen quad of depth texture\n  // to see the difference of depth value using reversed z compared to default depth buffer usage\n  // 0.0 will be the furthest and 1.0 will be the closest\n  const textureQuadPassPipline = device.createRenderPipeline({\n    vertex: {\n      module: device.createShaderModule({\n        code: wgslShaders.vertexTextureQuad,\n      }),\n      entryPoint: 'main',\n    },\n    fragment: {\n      module: device.createShaderModule({\n        code: wgslShaders.fragmentTextureQuad,\n      }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: 'bgra8unorm',\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n  });\n\n  const depthTexture = device.createTexture({\n    size: {\n      width: canvas.width,\n      height: canvas.height,\n    },\n    format: depthBufferFormat,\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.SAMPLED,\n  });\n  const depthTextureView = depthTexture.createView();\n\n  const defaultDepthTexture = device.createTexture({\n    size: {\n      width: canvas.width,\n      height: canvas.height,\n    },\n    format: depthBufferFormat,\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  const defaultDepthTextureView = defaultDepthTexture.createView();\n\n  const depthPrePassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [],\n    depthStencilAttachment: {\n      view: depthTextureView,\n\n      depthLoadValue: 1.0,\n      depthStoreOp: 'store',\n      stencilLoadValue: 0,\n      stencilStoreOp: 'store',\n    },\n  };\n\n  // drawPassDescriptor and drawPassLoadDescriptor are used for drawing\n  // the scene twice using different depth buffer mode on splitted viewport\n  // of the same canvas\n  // see the difference of the loadValue of the colorAttachments\n  const drawPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // view is acquired and set in render loop.\n        view: undefined,\n\n        loadValue: { r: 0.0, g: 0.0, b: 0.5, a: 1.0 },\n        storeOp: 'store',\n      },\n    ],\n    depthStencilAttachment: {\n      view: defaultDepthTextureView,\n\n      depthLoadValue: 1.0,\n      depthStoreOp: 'store',\n      stencilLoadValue: 0.0,\n      stencilStoreOp: 'store',\n    },\n  };\n  const drawPassLoadDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // attachment is acquired and set in render loop.\n        view: undefined,\n\n        loadValue: 'load',\n        storeOp: 'store',\n      },\n    ],\n    depthStencilAttachment: {\n      view: defaultDepthTextureView,\n\n      depthLoadValue: 1.0,\n      depthStoreOp: 'store',\n      stencilLoadValue: 0.0,\n      stencilStoreOp: 'store',\n    },\n  };\n  const drawPassDescriptors = [drawPassDescriptor, drawPassLoadDescriptor];\n\n  const textureQuadPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // view is acquired and set in render loop.\n        view: undefined,\n\n        loadValue: { r: 0.0, g: 0.0, b: 0.5, a: 1.0 },\n        storeOp: 'store',\n      },\n    ],\n  };\n  const textureQuadPassLoadDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // view is acquired and set in render loop.\n        view: undefined,\n\n        loadValue: 'load',\n        storeOp: 'store',\n      },\n    ],\n  };\n  const textureQuadPassDescriptors = [\n    textureQuadPassDescriptor,\n    textureQuadPassLoadDescriptor,\n  ];\n\n  const depthTextureBindGroupLayout = device.createBindGroupLayout({\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.FRAGMENT,\n        texture: {\n          sampleType: 'float',\n        },\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.FRAGMENT,\n        sampler: {\n          type: 'filtering',\n        },\n      },\n    ],\n  });\n  const depthTextureBindGroup = device.createBindGroup({\n    layout: depthTextureBindGroupLayout,\n    entries: [\n      {\n        binding: 0,\n        resource: depthTextureView,\n      },\n      {\n        binding: 1,\n        resource: device.createSampler(),\n      },\n    ],\n  });\n\n  const uniformBufferSize = numInstances * matrixStride;\n\n  const uniformBuffer = device.createBuffer({\n    size: uniformBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  const cameraMatrixBuffer = device.createBuffer({\n    size: 4 * 16, // 4x4 matrix\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  const cameraMatrixReversedDepthBuffer = device.createBuffer({\n    size: 4 * 16, // 4x4 matrix\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  const uniformBindGroups = [\n    device.createBindGroup({\n      layout: depthPrePassPipelines[DepthBufferMode.Default].getBindGroupLayout(\n        0\n      ),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: cameraMatrixBuffer,\n          },\n        },\n      ],\n    }),\n    device.createBindGroup({\n      layout: depthPrePassPipelines[\n        DepthBufferMode.Reversed\n      ].getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: cameraMatrixReversedDepthBuffer,\n          },\n        },\n      ],\n    }),\n  ];\n\n  const modelMatrices = new Array(numInstances);\n  const mvpMatricesData = new Float32Array(matrixFloatCount * numInstances);\n\n  let m = 0;\n  for (let x = 0; x < xCount; x++) {\n    for (let y = 0; y < yCount; y++) {\n      const z = -800 * m;\n      const s = 1 + 50 * m;\n\n      modelMatrices[m] = mat4.create();\n\n      mat4.translate(\n        modelMatrices[m],\n        modelMatrices[m],\n        vec3.fromValues(\n          x - xCount / 2 + 0.5,\n          (4.0 - 0.2 * z) * (y - yCount / 2 + 1.0),\n          z\n        )\n      );\n      mat4.scale(modelMatrices[m], modelMatrices[m], vec3.fromValues(s, s, s));\n\n      m++;\n    }\n  }\n\n  const viewMatrix = mat4.create();\n  mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -12));\n\n  const aspect = Math.abs(canvas.width / canvas.height) * 0.5;\n  const projectionMatrix = mat4.create();\n  perspectiveZO(projectionMatrix, (2 * Math.PI) / 5, aspect, 5, Infinity);\n\n  const viewProjectionMatrix = mat4.create();\n  mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);\n  const reversedRangeViewProjectionMatrix = mat4.create();\n  // to use 1/z we just multiple depthRangeRemapMatrix to our default camera view projection matrix\n  mat4.multiply(\n    reversedRangeViewProjectionMatrix,\n    depthRangeRemapMatrix,\n    viewProjectionMatrix\n  );\n\n  let bufferData = viewProjectionMatrix as Float32Array;\n  device.queue.writeBuffer(\n    cameraMatrixBuffer,\n    0,\n    bufferData.buffer,\n    bufferData.byteOffset,\n    bufferData.byteLength\n  );\n  bufferData = reversedRangeViewProjectionMatrix as Float32Array;\n  device.queue.writeBuffer(\n    cameraMatrixReversedDepthBuffer,\n    0,\n    bufferData.buffer,\n    bufferData.byteOffset,\n    bufferData.byteLength\n  );\n\n  const tmpMat4 = mat4.create();\n  function updateTransformationMatrix() {\n    const now = Date.now() / 1000;\n\n    for (let i = 0, m = 0; i < numInstances; i++, m += matrixFloatCount) {\n      mat4.rotate(\n        tmpMat4,\n        modelMatrices[i],\n        (Math.PI / 180) * 30,\n        vec3.fromValues(Math.sin(now), Math.cos(now), 0)\n      );\n      mvpMatricesData.set(tmpMat4, m);\n    }\n  }\n\n  const settings = {\n    mode: 'color',\n  };\n  gui.add(settings, 'mode', ['color', 'precision-error', 'depth-texture']);\n\n  return function frame() {\n    updateTransformationMatrix();\n    device.queue.writeBuffer(\n      uniformBuffer,\n      0,\n      mvpMatricesData.buffer,\n      mvpMatricesData.byteOffset,\n      mvpMatricesData.byteLength\n    );\n\n    const attachment = swapChain.getCurrentTexture().createView();\n    const commandEncoder = device.createCommandEncoder();\n    if (settings.mode === 'color') {\n      for (const m of depthBufferModes) {\n        drawPassDescriptors[m].colorAttachments[0].view = attachment;\n        drawPassDescriptors[m].depthStencilAttachment.depthLoadValue =\n          depthLoadValues[m];\n        const colorPass = commandEncoder.beginRenderPass(\n          drawPassDescriptors[m]\n        );\n        colorPass.setPipeline(colorPassPipelines[m]);\n        colorPass.setBindGroup(0, uniformBindGroups[m]);\n        colorPass.setVertexBuffer(0, verticesBuffer);\n        colorPass.setViewport(\n          kViewportWidth * m,\n          0,\n          kViewportWidth,\n          kDefaultCanvasHeight,\n          0,\n          1\n        );\n        colorPass.draw(geometryDrawCount, numInstances, 0, 0);\n        colorPass.endPass();\n      }\n    } else if (settings.mode === 'precision-error') {\n      for (const m of depthBufferModes) {\n        {\n          depthPrePassDescriptor.depthStencilAttachment.depthLoadValue =\n            depthLoadValues[m];\n          const depthPrePass = commandEncoder.beginRenderPass(\n            depthPrePassDescriptor\n          );\n          depthPrePass.setPipeline(depthPrePassPipelines[m]);\n          depthPrePass.setBindGroup(0, uniformBindGroups[m]);\n          depthPrePass.setVertexBuffer(0, verticesBuffer);\n          depthPrePass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          depthPrePass.draw(geometryDrawCount, numInstances, 0, 0);\n          depthPrePass.endPass();\n        }\n        {\n          drawPassDescriptors[m].colorAttachments[0].view = attachment;\n          drawPassDescriptors[m].depthStencilAttachment.depthLoadValue =\n            depthLoadValues[m];\n          const precisionErrorPass = commandEncoder.beginRenderPass(\n            drawPassDescriptors[m]\n          );\n          precisionErrorPass.setPipeline(precisionPassPipelines[m]);\n          precisionErrorPass.setBindGroup(0, uniformBindGroups[m]);\n          precisionErrorPass.setBindGroup(1, depthTextureBindGroup);\n          precisionErrorPass.setVertexBuffer(0, verticesBuffer);\n          precisionErrorPass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          precisionErrorPass.draw(geometryDrawCount, numInstances, 0, 0);\n          precisionErrorPass.endPass();\n        }\n      }\n    } else {\n      // depth texture quad\n      for (const m of depthBufferModes) {\n        {\n          depthPrePassDescriptor.depthStencilAttachment.depthLoadValue =\n            depthLoadValues[m];\n          const depthPrePass = commandEncoder.beginRenderPass(\n            depthPrePassDescriptor\n          );\n          depthPrePass.setPipeline(depthPrePassPipelines[m]);\n          depthPrePass.setBindGroup(0, uniformBindGroups[m]);\n          depthPrePass.setVertexBuffer(0, verticesBuffer);\n          depthPrePass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          depthPrePass.draw(geometryDrawCount, numInstances, 0, 0);\n          depthPrePass.endPass();\n        }\n        {\n          textureQuadPassDescriptors[m].colorAttachments[0].view = attachment;\n          const depthTextureQuadPass = commandEncoder.beginRenderPass(\n            textureQuadPassDescriptors[m]\n          );\n          depthTextureQuadPass.setPipeline(textureQuadPassPipline);\n          depthTextureQuadPass.setBindGroup(0, depthTextureBindGroup);\n          depthTextureQuadPass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          depthTextureQuadPass.draw(6, 1, 0, 0);\n          depthTextureQuadPass.endPass();\n        }\n      }\n    }\n    device.queue.submit([commandEncoder.finish()]);\n  };\n}\n\nconst wgslShaders = {\n  vertex: `\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(${matrixStride})]] array<mat4x4<f32>, ${numInstances}>;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] fragColor : vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] instanceIdx : u32,\n        [[location(0)]] position : vec4<f32>,\n        [[location(1)]] color : vec4<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  output.fragColor = color;\n  return output;\n}\n`,\n  fragment: `\n[[stage(fragment)]]\nfn main([[location(0)]] fragColor : vec4<f32>) -> [[location(0)]] vec4<f32> {\n  return fragColor;\n}\n`,\n  vertexDepthPrePass: `\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(${matrixStride})]] array<mat4x4<f32>, ${numInstances}>;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] instanceIdx : u32,\n        [[location(0)]] position : vec4<f32>)\n     -> [[builtin(position)]] vec4<f32> {\n  return camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n}\n`,\n  fragmentDepthPrePass: `\n[[stage(fragment)]]\nfn main() {\n}\n`,\n  vertexPrecisionErrorPass: `\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(${matrixStride})]] array<mat4x4<f32>, ${numInstances}>;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\nstruct VertexOutput {\n  [[builtin(position)]] Position : vec4<f32>;\n  [[location(0)]] clipPos : vec4<f32>;\n};\n\n[[stage(vertex)]]\nfn main([[builtin(instance_index)]] instanceIdx : u32,\n        [[location(0)]] position : vec4<f32>) -> VertexOutput {\n  var output : VertexOutput;\n  output.Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  output.clipPos = output.Position;\n  return output;\n}\n`,\n  fragmentPrecisionErrorPass: `\n[[group(1), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(1), binding(1)]] var depthSampler: sampler;\n\n[[stage(fragment)]]\nfn main([[builtin(position)]] coord : vec4<f32>,\n        [[location(0)]] clipPos : vec4<f32>)\n     -> [[location(0)]] vec4<f32> {\n  let depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(${kDefaultCanvasWidth.toFixed(\n    1\n  )}, ${kDefaultCanvasHeight.toFixed(1)})).r;\n  let v : f32 = abs(clipPos.z / clipPos.w - depthValue) * 2000000.0;\n  return vec4<f32>(v, v, v, 1.0) ;\n}\n`,\n  vertexTextureQuad: `\nlet pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n  vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0), vec2<f32>(-1.0, 1.0),\n  vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, -1.0), vec2<f32>(1.0, 1.0));\n\n[[stage(vertex)]]\nfn main([[builtin(vertex_index)]] VertexIndex : u32)\n     -> [[builtin(position)]] vec4<f32> {\n  return vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n}\n`,\n  fragmentTextureQuad: `\n[[group(0), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var depthSampler: sampler;\n\n[[stage(fragment)]]\nfn main([[builtin(position)]] coord : vec4<f32>)\n     -> [[location(0)]] vec4<f32> {\n  let depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(${kDefaultCanvasWidth.toFixed(\n    1\n  )}, ${kDefaultCanvasHeight.toFixed(1)})).r;\n  return vec4<f32>(depthValue, depthValue, depthValue, 1.0);\n}\n`,\n};\n\nexport default makeBasicExample({\n  name: 'Reversed Z',\n  description: `This example shows the use of reversed z technique for better utilization of depth buffer precision.\n    The left column uses regular method, while the right one uses reversed z technique.\n    Both are using depth32float as their depth buffer format. A set of red and green planes are positioned very close to each other.\n    Higher sets are placed further from camera (and are scaled for better visual purpose).\n    To use reversed z to render your scene, you will need depth store value to be 0.0, depth compare function to be greater,\n    and remap depth range by multiplying an additional matrix to your projection matrix.\n    Related reading:\n    https://developer.nvidia.com/content/depth-precision-visualized\n    https://thxforthefish.com/posts/reverse_z/\n    `,\n  slug: 'reversedZ',\n  init,\n  source: __SOURCE__,\n  gui: true,\n});\n",gui:!0})},XAJ8:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/samples/reversedZ",function(){return t("7r7F")}])}},[["XAJ8",0,1,4,2,3,5,6]]]);