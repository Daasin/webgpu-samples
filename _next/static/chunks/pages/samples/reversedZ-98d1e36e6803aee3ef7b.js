_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[18],{"7r7F":function(e,n,t){"use strict";t.r(n),t.d(n,"geometryVertexArray",(function(){return P}));var r,a,o=t("o0o1"),i=t.n(o),s=t("HaE+"),c=t("rePB"),d=t("IOcx"),u=t("SoUo"),l=t("PpzT");function f(e,n){var t;if("undefined"===typeof Symbol||null==e[Symbol.iterator]){if(Array.isArray(e)||(t=function(e,n){if(!e)return;if("string"===typeof e)return p(e,n);var t=Object.prototype.toString.call(e).slice(8,-1);"Object"===t&&e.constructor&&(t=e.constructor.name);if("Map"===t||"Set"===t)return Array.from(e);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return p(e,n)}(e))||n&&e&&"number"===typeof e.length){t&&(e=t);var r=0,a=function(){};return{s:a,n:function(){return r>=e.length?{done:!0}:{done:!1,value:e[r++]}},e:function(e){throw e},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,i=!0,s=!1;return{s:function(){t=e[Symbol.iterator]()},n:function(){var e=t.next();return i=e.done,e},e:function(e){s=!0,o=e},f:function(){try{i||null==t.return||t.return()}finally{if(s)throw o}}}}function p(e,n){(null==n||n>e.length)&&(n=e.length);for(var t=0,r=new Array(n);t<n;t++)r[t]=e[t];return r}var m,h=32,v=12,g=1e-4,P=new Float32Array([-1.5,-1,g,1,1,0,0,1,.5,-1,g,1,1,0,0,1,-1.5,1,g,1,1,0,0,1,.5,-1,g,1,1,0,0,1,.5,1,g,1,1,0,0,1,-1.5,1,g,1,1,0,0,1,-.5,-1,-g,1,0,1,0,1,1.5,-1,-g,1,0,1,0,1,-.5,1,-g,1,0,1,0,1,1.5,-1,-g,1,0,1,0,1,1.5,1,-g,1,0,1,0,1,-.5,1,-g,1,0,1,0,1]),x=u.b/2,b=d.a.create();function y(e,n,t,r,a){var o=1/Math.tan(n/2);if(e[0]=o/t,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=a&&a!==1/0){var i=1/(r-a);e[10]=a*i,e[14]=a*r*i}else e[10]=-1,e[14]=-r;return e}b[10]=-1,b[14]=1,function(e){e[e.Default=0]="Default",e[e.Reversed=1]="Reversed"}(m||(m={}));var M=[m.Default,m.Reversed],S=(r={},Object(c.a)(r,m.Default,"less"),Object(c.a)(r,m.Reversed,"greater"),r),w=(a={},Object(c.a)(a,m.Default,1),Object(c.a)(a,m.Reversed,0),a);function D(){return(D=Object(s.a)(i.a.mark((function e(n,t,r){var a,o,s,c,p,g,D,V,R,G,L,T,U,A,E,_,I,F,j,k,O,z,Q,W,N,q,H,$,Z,X,Y,J,K,ee,ne,te,re,ae,oe,ie,se,ce,de;return i.a.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return ce=function(){for(var e=Date.now()/1e3,n=0,t=0;n<5;n++,t+=16)d.a.rotate(se,$[n],Math.PI/180*30,d.b.fromValues(Math.sin(e),Math.cos(e),0)),Z.set(se,t)},e.next=3,navigator.gpu.requestAdapter();case 3:return a=e.sent,e.next=6,a.requestDevice();case 6:return o=e.sent,e.next=9,Object(l.a)();case 9:for(s=e.sent,c=n.getContext("gpupresent"),p=c.configureSwapChain({device:o,format:"bgra8unorm"}),g=o.createBuffer({size:P.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(g.getMappedRange()).set(P),g.unmap(),D="depth24plus",V={vertex:{module:t?o.createShaderModule({code:B.vertexDepthPrePass}):o.createShaderModule({code:C.vertexDepthPrePass,transform:function(e){return s.compileGLSL(e,"vertex")}}),entryPoint:"main",buffers:[{arrayStride:h,attributes:[{shaderLocation:0,offset:0,format:"float32x4"}]}]},fragment:{module:t?o.createShaderModule({code:B.fragmentDepthPrePass}):o.createShaderModule({code:C.fragmentDepthPrePass,transform:function(e){return s.compileGLSL(e,"fragment")}}),entryPoint:"main",targets:[]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:D}},R=[],V.depthStencil.depthCompare=S[m.Default],R[m.Default]=o.createRenderPipeline(V),V.depthStencil.depthCompare=S[m.Reversed],R[m.Reversed]=o.createRenderPipeline(V),G={vertex:{module:t?o.createShaderModule({code:B.vertexPrecisionErrorPass}):o.createShaderModule({code:C.vertexPrecisionErrorPass,transform:function(e){return s.compileGLSL(e,"vertex")}}),entryPoint:"main",buffers:[{arrayStride:h,attributes:[{shaderLocation:0,offset:0,format:"float32x4"}]}]},fragment:{module:t?o.createShaderModule({code:B.fragmentPrecisionErrorPass}):o.createShaderModule({code:C.fragmentPrecisionErrorPass,transform:function(e){return s.compileGLSL(e,"fragment")}}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:D}},L=[],G.depthStencil.depthCompare=S[m.Default],L[m.Default]=o.createRenderPipeline(G),G.depthStencil.depthCompare=S[m.Reversed],L[m.Reversed]=o.createRenderPipeline(G),T={vertex:{module:t?o.createShaderModule({code:B.vertex}):o.createShaderModule({code:C.vertex,transform:function(e){return s.compileGLSL(e,"vertex")}}),entryPoint:"main",buffers:[{arrayStride:h,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:16,format:"float32x4"}]}]},fragment:{module:t?o.createShaderModule({code:B.fragment}):o.createShaderModule({code:C.fragment,transform:function(e){return s.compileGLSL(e,"fragment")}}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:D}},U=[],T.depthStencil.depthCompare=S[m.Default],U[m.Default]=o.createRenderPipeline(T),T.depthStencil.depthCompare=S[m.Reversed],U[m.Reversed]=o.createRenderPipeline(T),A=o.createRenderPipeline({vertex:{module:t?o.createShaderModule({code:B.vertexTextureQuad}):o.createShaderModule({code:C.vertexTextureQuad,transform:function(e){return s.compileGLSL(e,"vertex")}}),entryPoint:"main"},fragment:{module:t?o.createShaderModule({code:B.fragmentTextureQuad}):o.createShaderModule({code:C.fragmentTextureQuad,transform:function(e){return s.compileGLSL(e,"fragment")}}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list"}}),E=o.createTexture({size:{width:n.width,height:n.height},format:D,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.SAMPLED}),_=E.createView(),I=o.createTexture({size:{width:n.width,height:n.height},format:D,usage:GPUTextureUsage.RENDER_ATTACHMENT}),F=I.createView(),j={colorAttachments:[],depthStencilAttachment:{attachment:_,depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},k=[{colorAttachments:[{attachment:void 0,loadValue:{r:0,g:0,b:.5,a:1}}],depthStencilAttachment:{attachment:F,depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}},{colorAttachments:[{attachment:void 0,loadValue:"load"}],depthStencilAttachment:{attachment:F,depthLoadValue:1,depthStoreOp:"store",stencilLoadValue:0,stencilStoreOp:"store"}}],O=[{colorAttachments:[{attachment:void 0,loadValue:{r:0,g:0,b:.5,a:1}}]},{colorAttachments:[{attachment:void 0,loadValue:"load"}]}],z=o.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"filtering"}}]}),Q=o.createBindGroup({layout:z,entries:[{binding:0,resource:_},{binding:1,resource:o.createSampler()}]}),320,W=o.createBuffer({size:320,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),N=o.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),q=o.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),H=[o.createBindGroup({layout:R[m.Default].getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:W}},{binding:1,resource:{buffer:N}}]}),o.createBindGroup({layout:R[m.Reversed].getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:W}},{binding:1,resource:{buffer:q}}]})],$=new Array(5),Z=new Float32Array(80),X=0,Y=0;Y<1;Y++)for(J=0;J<5;J++)K=-800*X,ee=1+50*X,$[X]=d.a.create(),d.a.translate($[X],$[X],d.b.fromValues(Y-.5+.5,(4-.2*K)*(J-2.5+1),K)),d.a.scale($[X],$[X],d.b.fromValues(ee,ee,ee)),X++;return ne=d.a.create(),d.a.translate(ne,ne,d.b.fromValues(0,0,-12)),te=.5*Math.abs(n.width/n.height),y(re=d.a.create(),2*Math.PI/5,te,5,1/0),ae=d.a.create(),d.a.multiply(ae,re,ne),oe=d.a.create(),d.a.multiply(oe,b,ae),ie=ae,o.queue.writeBuffer(N,0,ie.buffer,ie.byteOffset,ie.byteLength),ie=oe,o.queue.writeBuffer(q,0,ie.buffer,ie.byteOffset,ie.byteLength),se=d.a.create(),de={mode:"color"},r.add(de,"mode",["color","precision-error","depth-texture"]),e.abrupt("return",(function(){ce(),o.queue.writeBuffer(W,0,Z.buffer,Z.byteOffset,Z.byteLength);var e=p.getCurrentTexture().createView(),n=o.createCommandEncoder();if("color"===de.mode){var t,r=f(M);try{for(r.s();!(t=r.n()).done;){var a=t.value;k[a].colorAttachments[0].attachment=e,k[a].depthStencilAttachment.depthLoadValue=w[a];var i=n.beginRenderPass(k[a]);i.setPipeline(U[a]),i.setBindGroup(0,H[a]),i.setVertexBuffer(0,g),i.setViewport(x*a,0,x,u.a,0,1),i.draw(v,5,0,0),i.endPass()}}catch(D){r.e(D)}finally{r.f()}}else if("precision-error"===de.mode){var s,c=f(M);try{for(c.s();!(s=c.n()).done;){var d=s.value;j.depthStencilAttachment.depthLoadValue=w[d];var l=n.beginRenderPass(j);l.setPipeline(R[d]),l.setBindGroup(0,H[d]),l.setVertexBuffer(0,g),l.setViewport(x*d,0,x,u.a,0,1),l.draw(v,5,0,0),l.endPass(),k[d].colorAttachments[0].attachment=e,k[d].depthStencilAttachment.depthLoadValue=w[d];var m=n.beginRenderPass(k[d]);m.setPipeline(L[d]),m.setBindGroup(0,H[d]),m.setBindGroup(1,Q),m.setVertexBuffer(0,g),m.setViewport(x*d,0,x,u.a,0,1),m.draw(v,5,0,0),m.endPass()}}catch(D){c.e(D)}finally{c.f()}}else{var h,P=f(M);try{for(P.s();!(h=P.n()).done;){var b=h.value;j.depthStencilAttachment.depthLoadValue=w[b];var y=n.beginRenderPass(j);y.setPipeline(R[b]),y.setBindGroup(0,H[b]),y.setVertexBuffer(0,g),y.setViewport(x*b,0,x,u.a,0,1),y.draw(v,5,0,0),y.endPass(),O[b].colorAttachments[0].attachment=e;var S=n.beginRenderPass(O[b]);S.setPipeline(A),S.setBindGroup(0,Q),S.setViewport(x*b,0,x,u.a,0,1),S.draw(6,1,0,0),S.endPass()}}catch(D){P.e(D)}finally{P.f()}}o.queue.submit([n.finish()])}));case 74:case"end":return e.stop()}}),e)})))).apply(this,arguments)}var C={vertex:"#version 450\nlayout(set = 0, binding = 0) uniform Uniforms {\n  mat4 modelMatrix[".concat(5,"];\n} uniforms;\n\nlayout(set = 0, binding = 1) uniform CameraMatrix {\n  mat4 viewProjectionMatrix;\n} camera;\n\nlayout(location = 0) in vec4 position;\nlayout(location = 1) in vec4 color;\n\nlayout(location = 0) out vec4 fragColor;\n\nvoid main() {\n  gl_Position = camera.viewProjectionMatrix * uniforms.modelMatrix[gl_InstanceIndex] * position;\n  fragColor = color;\n}\n"),fragment:"#version 450\nlayout(location = 0) in vec4 fragColor;\nlayout(location = 0) out vec4 outColor;\n\nvoid main() {\n  outColor = fragColor;\n}\n  ",vertexDepthPrePass:"#version 450\nlayout(set = 0, binding = 0) uniform Uniforms {\n  mat4 modelMatrix[".concat(5,"];\n} uniforms;\n\nlayout(set = 0, binding = 1) uniform CameraMatrix {\n  mat4 viewProjectionMatrix;\n} camera;\n\nlayout(location = 0) in vec4 position;\n\nvoid main() {\n  gl_Position = camera.viewProjectionMatrix * uniforms.modelMatrix[gl_InstanceIndex] * position;\n}\n"),fragmentDepthPrePass:"#version 450\nvoid main() {\n}\n",vertexPrecisionErrorPass:"#version 450\nlayout(set = 0, binding = 0) uniform Uniforms {\n  mat4 modelMatrix[".concat(5,"];\n} uniforms;\n\nlayout(set = 0, binding = 1) uniform CameraMatrix {\n  mat4 viewProjectionMatrix;\n} camera;\n\n\nlayout(location = 0) in vec4 position;\n\nlayout(location = 0) out vec4 clipPos;\n\nvoid main() {\n  gl_Position = camera.viewProjectionMatrix * uniforms.modelMatrix[gl_InstanceIndex] * position;\n  clipPos = gl_Position;\n}\n"),fragmentPrecisionErrorPass:"#version 450\nlayout(location = 0) in vec4 clipPos;\nlayout(location = 0) out vec4 outColor;\n\nlayout(set = 1, binding = 0) uniform texture2D depthMap;\nlayout(set = 1, binding = 1) uniform sampler depthSampler;\n\nvoid main() {\n  vec2 fragUV = gl_FragCoord.xy / vec2(".concat(u.b.toFixed(1),", ").concat(u.a.toFixed(1),");\n  float depthValue = texture(sampler2D(depthMap, depthSampler), fragUV).r;\n  float error = abs(clipPos.z / clipPos.w - depthValue);\n  outColor = vec4(vec3(error * 2000000.0), 1.0);\n}\n"),vertexTextureQuad:"#version 450\nconst vec2 pos[6] = vec2[6](\n  vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f), vec2(-1.0f, 1.0f),\n  vec2(-1.0f, 1.0f), vec2(1.0f, -1.0f), vec2(1.0f, 1.0f)\n);\nvoid main() {\n  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n}\n  ",fragmentTextureQuad:"#version 450\nlayout(set = 0, binding = 0) uniform texture2D map;\nlayout(set = 0, binding = 1) uniform sampler mapSampler;\n\nlayout(location = 0) out vec4 outColor;\n\nvoid main() {\n  vec2 fragUV = gl_FragCoord.xy / vec2(".concat(u.b.toFixed(1),", ").concat(u.a.toFixed(1),");\n  float value = texture(sampler2D(map, mapSampler), fragUV).r;\n  outColor = vec4(vec3(value), 1.0);\n}\n  ")},B={vertex:"\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(".concat(64,")]] array<mat4x4<f32>, ").concat(5,">;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[builtin(instance_index)]] var<in> instanceIdx : u32;\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[location(0)]] var<in> position : vec4<f32>;\n[[location(1)]] var<in> color : vec4<f32>;\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[location(0)]] var<out> fragColor : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  fragColor = color;\n}\n"),fragment:"\n[[location(0)]] var<in> fragColor : vec4<f32>;\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  outColor = fragColor;\n}\n",vertexDepthPrePass:"\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(".concat(64,")]] array<mat4x4<f32>, ").concat(5,">;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[builtin(instance_index)]] var<in> instanceIdx : u32;\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[location(0)]] var<in> position : vec4<f32>;\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n}\n"),fragmentDepthPrePass:"\n[[stage(fragment)]]\nfn main() -> void {\n}\n",vertexPrecisionErrorPass:"\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(".concat(64,")]] array<mat4x4<f32>, ").concat(5,">;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[builtin(instance_index)]] var<in> instanceIdx : u32;\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[location(0)]] var<in> position : vec4<f32>;\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[location(0)]] var<out> clipPos : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  clipPos = Position;\n}\n"),fragmentPrecisionErrorPass:"\n[[group(1), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(1), binding(1)]] var depthSampler: sampler;\n\n[[location(0)]] var<in> clipPos : vec4<f32>;\n[[builtin(frag_coord)]] var<in> coord : vec4<f32>;\n\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  const depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(".concat(u.b.toFixed(1),", ").concat(u.a.toFixed(1),")).r;\n  const v : f32 = abs(clipPos.z / clipPos.w - depthValue) * 2000000.0;\n  outColor = vec4<f32>(v, v, v, 1.0) ;\n}\n"),vertexTextureQuad:"\nconst pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n  vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0), vec2<f32>(-1.0, 1.0),\n  vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, -1.0), vec2<f32>(1.0, 1.0));\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[builtin(vertex_index)]] var<in> VertexIndex : u32;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n}\n",fragmentTextureQuad:"\n[[group(0), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var depthSampler: sampler;\n\n[[builtin(frag_coord)]] var<in> coord : vec4<f32>;\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  const depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(".concat(u.b.toFixed(1),", ").concat(u.a.toFixed(1),")).r;\n  outColor = vec4<f32>(depthValue, depthValue, depthValue, 1.0);\n}\n")};n.default=Object(u.c)({name:"Reversed Z",description:"This example shows the use of reversed z technique for better utilization of depth buffer precision.\n    The left column uses regular method, while the right one uses reversed z technique.\n    Both are using depth24plus as their depth buffer format. A set of red and green planes are positioned very close to each other.\n    Higher sets are placed further from camera (and are scaled for better visual purpose).\n    To use reversed z to render your scene, you will need depth store value to be 0.0, depth compare function to be greater,\n    and remap depth range by multiplying an additional matrix to your projection matrix.\n    Related reading:\n    https://developer.nvidia.com/content/depth-precision-visualized\n    https://thxforthefish.com/posts/reverse_z/\n    ",slug:"reversedZ",init:function(e,n,t){return D.apply(this,arguments)},wgslShaders:B,glslShaders:C,source:"import { mat4, vec3 } from 'gl-matrix';\nimport type { GUI } from 'dat.gui';\nimport {\n  kDefaultCanvasWidth,\n  kDefaultCanvasHeight,\n  makeBasicExample,\n} from '../../components/basicExample';\nimport glslangModule from '../../glslang';\n\n// Two planes close to each other for depth precision test\nconst geometryVertexSize = 4 * 8; // Byte size of one geometry vertex.\nconst geometryPositionOffset = 0;\nconst geometryColorOffset = 4 * 4; // Byte offset of geometry vertex color attribute.\nconst geometryDrawCount = 6 * 2;\n\nconst d = 0.0001; // half distance between two planes\nconst o = 0.5; // half x offset to shift planes so they are only partially overlaping\n\n// prettier-ignore\nexport const geometryVertexArray = new Float32Array([\n  // float4 position, float4 color\n  -1 - o, -1, d, 1, 1, 0, 0, 1, \n   1 - o, -1, d, 1,  1, 0, 0, 1, \n  -1 - o, 1, d, 1,  1, 0, 0, 1, \n   1 - o, -1,  d, 1, 1, 0, 0, 1, \n   1 - o, 1,  d, 1,  1, 0, 0, 1,\n  -1 - o, 1, d, 1,  1, 0, 0, 1, \n \n  -1 + o, -1, -d, 1, 0, 1, 0, 1, \n   1 + o, -1, -d, 1,  0, 1, 0, 1, \n  -1 + o, 1, -d, 1,  0, 1, 0, 1, \n   1 + o, -1,  -d, 1, 0, 1, 0, 1, \n   1 + o, 1,  -d, 1,  0, 1, 0, 1, \n  -1 + o, 1, -d, 1,  0, 1, 0, 1, \n]);\n\nconst kViewportWidth = kDefaultCanvasWidth / 2;\n\nconst xCount = 1;\nconst yCount = 5;\nconst numInstances = xCount * yCount;\nconst matrixFloatCount = 16; // 4x4 matrix\nconst matrixStride = 4 * matrixFloatCount;\n\nconst depthRangeRemapMatrix = mat4.create();\ndepthRangeRemapMatrix[10] = -1;\ndepthRangeRemapMatrix[14] = 1;\n\n// https://github.com/toji/gl-matrix/commit/e906eb7bb02822a81b1d197c6b5b33563c0403c0\nfunction perspectiveZO(out, fovy, aspect, near, far) {\n  const f = 1.0 / Math.tan(fovy / 2);\n  out[0] = f / aspect;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 0;\n  out[4] = 0;\n  out[5] = f;\n  out[6] = 0;\n  out[7] = 0;\n  out[8] = 0;\n  out[9] = 0;\n  out[11] = -1;\n  out[12] = 0;\n  out[13] = 0;\n  out[15] = 0;\n  if (far != null && far !== Infinity) {\n    const nf = 1 / (near - far);\n    out[10] = far * nf;\n    out[14] = far * near * nf;\n  } else {\n    out[10] = -1;\n    out[14] = -near;\n  }\n  return out;\n}\n\nenum DepthBufferMode {\n  Default = 0,\n  Reversed,\n}\n\nconst depthBufferModes: DepthBufferMode[] = [\n  DepthBufferMode.Default,\n  DepthBufferMode.Reversed,\n];\nconst depthCompareFuncs = {\n  [DepthBufferMode.Default]: 'less' as GPUCompareFunction,\n  [DepthBufferMode.Reversed]: 'greater' as GPUCompareFunction,\n};\nconst depthLoadValues = {\n  [DepthBufferMode.Default]: 1.0,\n  [DepthBufferMode.Reversed]: 0.0,\n};\n\nasync function init(canvas: HTMLCanvasElement, useWGSL: boolean, gui?: GUI) {\n  const adapter = await navigator.gpu.requestAdapter();\n  const device = await adapter.requestDevice();\n  const glslang = await glslangModule();\n\n  const context = canvas.getContext('gpupresent');\n\n  const swapChain = context.configureSwapChain({\n    device,\n    format: 'bgra8unorm',\n  });\n\n  const verticesBuffer = device.createBuffer({\n    size: geometryVertexArray.byteLength,\n    usage: GPUBufferUsage.VERTEX,\n    mappedAtCreation: true,\n  });\n  new Float32Array(verticesBuffer.getMappedRange()).set(geometryVertexArray);\n  verticesBuffer.unmap();\n\n  const depthBufferFormat = 'depth24plus';\n\n  // depthPrePass is used to render scene to the depth texture\n  // this is not needed if you just want to use reversed z to render a scene\n  const depthPrePassRenderPipelineDescriptorBase: GPURenderPipelineDescriptor = {\n    vertex: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.vertexDepthPrePass,\n          })\n        : device.createShaderModule({\n            code: glslShaders.vertexDepthPrePass,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'vertex'),\n          }),\n      entryPoint: 'main',\n      buffers: [\n        {\n          arrayStride: geometryVertexSize,\n          attributes: [\n            {\n              // position\n              shaderLocation: 0,\n              offset: geometryPositionOffset,\n              format: 'float32x4',\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.fragmentDepthPrePass,\n          })\n        : device.createShaderModule({\n            code: glslShaders.fragmentDepthPrePass,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'fragment'),\n          }),\n      entryPoint: 'main',\n      targets: [],\n    },\n    primitive: {\n      topology: 'triangle-list',\n      cullMode: 'back',\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: depthBufferFormat,\n    },\n  };\n  // we need the depthCompare to fit the depth buffer mode we are using.\n  // this is the same for other passes\n  const depthPrePassPipelines: GPURenderPipeline[] = [];\n  depthPrePassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Default];\n  depthPrePassPipelines[DepthBufferMode.Default] = device.createRenderPipeline(\n    depthPrePassRenderPipelineDescriptorBase\n  );\n  depthPrePassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Reversed];\n  depthPrePassPipelines[DepthBufferMode.Reversed] = device.createRenderPipeline(\n    depthPrePassRenderPipelineDescriptorBase\n  );\n\n  // precisionPass is to draw precision error as color of depth value stored in depth buffer\n  // compared to that directly calcualated in the shader\n  const precisionPassRenderPipelineDescriptorBase: GPURenderPipelineDescriptor = {\n    vertex: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.vertexPrecisionErrorPass,\n          })\n        : device.createShaderModule({\n            code: glslShaders.vertexPrecisionErrorPass,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'vertex'),\n          }),\n      entryPoint: 'main',\n      buffers: [\n        {\n          arrayStride: geometryVertexSize,\n          attributes: [\n            {\n              // position\n              shaderLocation: 0,\n              offset: geometryPositionOffset,\n              format: 'float32x4',\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.fragmentPrecisionErrorPass,\n          })\n        : device.createShaderModule({\n            code: glslShaders.fragmentPrecisionErrorPass,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'fragment'),\n          }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: 'bgra8unorm',\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n      cullMode: 'back',\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: depthBufferFormat,\n    },\n  };\n  const precisionPassPipelines: GPURenderPipeline[] = [];\n  precisionPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Default];\n  precisionPassPipelines[DepthBufferMode.Default] = device.createRenderPipeline(\n    precisionPassRenderPipelineDescriptorBase\n  );\n  precisionPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Reversed];\n  precisionPassPipelines[\n    DepthBufferMode.Reversed\n  ] = device.createRenderPipeline(precisionPassRenderPipelineDescriptorBase);\n\n  // colorPass is the regular render pass to render the scene\n  const colorPassRenderPipelineDescriptorBase: GPURenderPipelineDescriptor = {\n    vertex: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.vertex,\n          })\n        : device.createShaderModule({\n            code: glslShaders.vertex,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'vertex'),\n          }),\n      entryPoint: 'main',\n      buffers: [\n        {\n          arrayStride: geometryVertexSize,\n          attributes: [\n            {\n              // position\n              shaderLocation: 0,\n              offset: geometryPositionOffset,\n              format: 'float32x4',\n            },\n            {\n              // color\n              shaderLocation: 1,\n              offset: geometryColorOffset,\n              format: 'float32x4',\n            },\n          ],\n        },\n      ],\n    },\n    fragment: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.fragment,\n          })\n        : device.createShaderModule({\n            code: glslShaders.fragment,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'fragment'),\n          }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: 'bgra8unorm',\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n      cullMode: 'back',\n    },\n    depthStencil: {\n      depthWriteEnabled: true,\n      depthCompare: 'less',\n      format: depthBufferFormat,\n    },\n  };\n  const colorPassPipelines: GPURenderPipeline[] = [];\n  colorPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Default];\n  colorPassPipelines[DepthBufferMode.Default] = device.createRenderPipeline(\n    colorPassRenderPipelineDescriptorBase\n  );\n  colorPassRenderPipelineDescriptorBase.depthStencil.depthCompare =\n    depthCompareFuncs[DepthBufferMode.Reversed];\n  colorPassPipelines[DepthBufferMode.Reversed] = device.createRenderPipeline(\n    colorPassRenderPipelineDescriptorBase\n  );\n\n  // textureQuadPass is draw a full screen quad of depth texture\n  // to see the difference of depth value using reversed z compared to default depth buffer usage\n  // 0.0 will be the furthest and 1.0 will be the closest\n  const textureQuadPassPipline = device.createRenderPipeline({\n    vertex: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.vertexTextureQuad,\n          })\n        : device.createShaderModule({\n            code: glslShaders.vertexTextureQuad,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'vertex'),\n          }),\n      entryPoint: 'main',\n    },\n    fragment: {\n      module: useWGSL\n        ? device.createShaderModule({\n            code: wgslShaders.fragmentTextureQuad,\n          })\n        : device.createShaderModule({\n            code: glslShaders.fragmentTextureQuad,\n            transform: (glsl) => glslang.compileGLSL(glsl, 'fragment'),\n          }),\n      entryPoint: 'main',\n      targets: [\n        {\n          format: 'bgra8unorm',\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n  });\n\n  const depthTexture = device.createTexture({\n    size: {\n      width: canvas.width,\n      height: canvas.height,\n    },\n    format: depthBufferFormat,\n    usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.SAMPLED,\n  });\n  const depthTextureView = depthTexture.createView();\n\n  const defaultDepthTexture = device.createTexture({\n    size: {\n      width: canvas.width,\n      height: canvas.height,\n    },\n    format: depthBufferFormat,\n    usage: GPUTextureUsage.RENDER_ATTACHMENT,\n  });\n  const defaultDepthTextureView = defaultDepthTexture.createView();\n\n  const depthPrePassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [],\n    depthStencilAttachment: {\n      attachment: depthTextureView,\n\n      depthLoadValue: 1.0,\n      depthStoreOp: 'store',\n      stencilLoadValue: 0,\n      stencilStoreOp: 'store',\n    },\n  };\n\n  // drawPassDescriptor and drawPassLoadDescriptor are used for drawing\n  // the scene twice using different depth buffer mode on splitted viewport\n  // of the same canvas\n  // see the difference of the loadValue of the colorAttachments\n  const drawPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // attachment is acquired and set in render loop.\n        attachment: undefined,\n\n        loadValue: { r: 0.0, g: 0.0, b: 0.5, a: 1.0 },\n      },\n    ],\n    depthStencilAttachment: {\n      attachment: defaultDepthTextureView,\n\n      depthLoadValue: 1.0,\n      depthStoreOp: 'store',\n      stencilLoadValue: 0.0,\n      stencilStoreOp: 'store',\n    },\n  };\n  const drawPassLoadDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // attachment is acquired and set in render loop.\n        attachment: undefined,\n\n        loadValue: 'load',\n      },\n    ],\n    depthStencilAttachment: {\n      attachment: defaultDepthTextureView,\n\n      depthLoadValue: 1.0,\n      depthStoreOp: 'store',\n      stencilLoadValue: 0.0,\n      stencilStoreOp: 'store',\n    },\n  };\n  const drawPassDescriptors = [drawPassDescriptor, drawPassLoadDescriptor];\n\n  const textureQuadPassDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // attachment is acquired and set in render loop.\n        attachment: undefined,\n\n        loadValue: { r: 0.0, g: 0.0, b: 0.5, a: 1.0 },\n      },\n    ],\n  };\n  const textureQuadPassLoadDescriptor: GPURenderPassDescriptor = {\n    colorAttachments: [\n      {\n        // attachment is acquired and set in render loop.\n        attachment: undefined,\n\n        loadValue: 'load',\n      },\n    ],\n  };\n  const textureQuadPassDescriptors = [\n    textureQuadPassDescriptor,\n    textureQuadPassLoadDescriptor,\n  ];\n\n  const depthTextureBindGroupLayout = device.createBindGroupLayout({\n    entries: [\n      {\n        binding: 0,\n        visibility: GPUShaderStage.FRAGMENT,\n        texture: {\n          sampleType: 'float',\n        },\n      },\n      {\n        binding: 1,\n        visibility: GPUShaderStage.FRAGMENT,\n        sampler: {\n          type: 'filtering',\n        },\n      },\n    ],\n  });\n  const depthTextureBindGroup = device.createBindGroup({\n    layout: depthTextureBindGroupLayout,\n    entries: [\n      {\n        binding: 0,\n        resource: depthTextureView,\n      },\n      {\n        binding: 1,\n        resource: device.createSampler(),\n      },\n    ],\n  });\n\n  const uniformBufferSize = numInstances * matrixStride;\n\n  const uniformBuffer = device.createBuffer({\n    size: uniformBufferSize,\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  const cameraMatrixBuffer = device.createBuffer({\n    size: 4 * 16, // 4x4 matrix\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n  const cameraMatrixReversedDepthBuffer = device.createBuffer({\n    size: 4 * 16, // 4x4 matrix\n    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n  });\n\n  const uniformBindGroups = [\n    device.createBindGroup({\n      layout: depthPrePassPipelines[DepthBufferMode.Default].getBindGroupLayout(\n        0\n      ),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: cameraMatrixBuffer,\n          },\n        },\n      ],\n    }),\n    device.createBindGroup({\n      layout: depthPrePassPipelines[\n        DepthBufferMode.Reversed\n      ].getBindGroupLayout(0),\n      entries: [\n        {\n          binding: 0,\n          resource: {\n            buffer: uniformBuffer,\n          },\n        },\n        {\n          binding: 1,\n          resource: {\n            buffer: cameraMatrixReversedDepthBuffer,\n          },\n        },\n      ],\n    }),\n  ];\n\n  const modelMatrices = new Array(numInstances);\n  const mvpMatricesData = new Float32Array(matrixFloatCount * numInstances);\n\n  let m = 0;\n  for (let x = 0; x < xCount; x++) {\n    for (let y = 0; y < yCount; y++) {\n      const z = -800 * m;\n      const s = 1 + 50 * m;\n\n      modelMatrices[m] = mat4.create();\n\n      mat4.translate(\n        modelMatrices[m],\n        modelMatrices[m],\n        vec3.fromValues(\n          x - xCount / 2 + 0.5,\n          (4.0 - 0.2 * z) * (y - yCount / 2 + 1.0),\n          z\n        )\n      );\n      mat4.scale(modelMatrices[m], modelMatrices[m], vec3.fromValues(s, s, s));\n\n      m++;\n    }\n  }\n\n  const viewMatrix = mat4.create();\n  mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -12));\n\n  const aspect = Math.abs(canvas.width / canvas.height) * 0.5;\n  const projectionMatrix = mat4.create();\n  perspectiveZO(projectionMatrix, (2 * Math.PI) / 5, aspect, 5, Infinity);\n\n  const viewProjectionMatrix = mat4.create();\n  mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);\n  const reversedRangeViewProjectionMatrix = mat4.create();\n  // to use 1/z we just multiple depthRangeRemapMatrix to our default camera view projection matrix\n  mat4.multiply(\n    reversedRangeViewProjectionMatrix,\n    depthRangeRemapMatrix,\n    viewProjectionMatrix\n  );\n\n  let bufferData = viewProjectionMatrix as Float32Array;\n  device.queue.writeBuffer(\n    cameraMatrixBuffer,\n    0,\n    bufferData.buffer,\n    bufferData.byteOffset,\n    bufferData.byteLength\n  );\n  bufferData = reversedRangeViewProjectionMatrix as Float32Array;\n  device.queue.writeBuffer(\n    cameraMatrixReversedDepthBuffer,\n    0,\n    bufferData.buffer,\n    bufferData.byteOffset,\n    bufferData.byteLength\n  );\n\n  const tmpMat4 = mat4.create();\n  function updateTransformationMatrix() {\n    const now = Date.now() / 1000;\n\n    for (let i = 0, m = 0; i < numInstances; i++, m += matrixFloatCount) {\n      mat4.rotate(\n        tmpMat4,\n        modelMatrices[i],\n        (Math.PI / 180) * 30,\n        vec3.fromValues(Math.sin(now), Math.cos(now), 0)\n      );\n      mvpMatricesData.set(tmpMat4, m);\n    }\n  }\n\n  const settings = {\n    mode: 'color',\n  };\n  gui.add(settings, 'mode', ['color', 'precision-error', 'depth-texture']);\n\n  return function frame() {\n    updateTransformationMatrix();\n    device.queue.writeBuffer(\n      uniformBuffer,\n      0,\n      mvpMatricesData.buffer,\n      mvpMatricesData.byteOffset,\n      mvpMatricesData.byteLength\n    );\n\n    const attachment = swapChain.getCurrentTexture().createView();\n    const commandEncoder = device.createCommandEncoder();\n    if (settings.mode === 'color') {\n      for (const m of depthBufferModes) {\n        drawPassDescriptors[m].colorAttachments[0].attachment = attachment;\n        drawPassDescriptors[m].depthStencilAttachment.depthLoadValue =\n          depthLoadValues[m];\n        const colorPass = commandEncoder.beginRenderPass(\n          drawPassDescriptors[m]\n        );\n        colorPass.setPipeline(colorPassPipelines[m]);\n        colorPass.setBindGroup(0, uniformBindGroups[m]);\n        colorPass.setVertexBuffer(0, verticesBuffer);\n        colorPass.setViewport(\n          kViewportWidth * m,\n          0,\n          kViewportWidth,\n          kDefaultCanvasHeight,\n          0,\n          1\n        );\n        colorPass.draw(geometryDrawCount, numInstances, 0, 0);\n        colorPass.endPass();\n      }\n    } else if (settings.mode === 'precision-error') {\n      for (const m of depthBufferModes) {\n        {\n          depthPrePassDescriptor.depthStencilAttachment.depthLoadValue =\n            depthLoadValues[m];\n          const depthPrePass = commandEncoder.beginRenderPass(\n            depthPrePassDescriptor\n          );\n          depthPrePass.setPipeline(depthPrePassPipelines[m]);\n          depthPrePass.setBindGroup(0, uniformBindGroups[m]);\n          depthPrePass.setVertexBuffer(0, verticesBuffer);\n          depthPrePass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          depthPrePass.draw(geometryDrawCount, numInstances, 0, 0);\n          depthPrePass.endPass();\n        }\n        {\n          drawPassDescriptors[m].colorAttachments[0].attachment = attachment;\n          drawPassDescriptors[m].depthStencilAttachment.depthLoadValue =\n            depthLoadValues[m];\n          const precisionErrorPass = commandEncoder.beginRenderPass(\n            drawPassDescriptors[m]\n          );\n          precisionErrorPass.setPipeline(precisionPassPipelines[m]);\n          precisionErrorPass.setBindGroup(0, uniformBindGroups[m]);\n          precisionErrorPass.setBindGroup(1, depthTextureBindGroup);\n          precisionErrorPass.setVertexBuffer(0, verticesBuffer);\n          precisionErrorPass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          precisionErrorPass.draw(geometryDrawCount, numInstances, 0, 0);\n          precisionErrorPass.endPass();\n        }\n      }\n    } else {\n      // depth texture quad\n      for (const m of depthBufferModes) {\n        {\n          depthPrePassDescriptor.depthStencilAttachment.depthLoadValue =\n            depthLoadValues[m];\n          const depthPrePass = commandEncoder.beginRenderPass(\n            depthPrePassDescriptor\n          );\n          depthPrePass.setPipeline(depthPrePassPipelines[m]);\n          depthPrePass.setBindGroup(0, uniformBindGroups[m]);\n          depthPrePass.setVertexBuffer(0, verticesBuffer);\n          depthPrePass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          depthPrePass.draw(geometryDrawCount, numInstances, 0, 0);\n          depthPrePass.endPass();\n        }\n        {\n          textureQuadPassDescriptors[\n            m\n          ].colorAttachments[0].attachment = attachment;\n          const depthTextureQuadPass = commandEncoder.beginRenderPass(\n            textureQuadPassDescriptors[m]\n          );\n          depthTextureQuadPass.setPipeline(textureQuadPassPipline);\n          depthTextureQuadPass.setBindGroup(0, depthTextureBindGroup);\n          depthTextureQuadPass.setViewport(\n            kViewportWidth * m,\n            0,\n            kViewportWidth,\n            kDefaultCanvasHeight,\n            0,\n            1\n          );\n          depthTextureQuadPass.draw(6, 1, 0, 0);\n          depthTextureQuadPass.endPass();\n        }\n      }\n    }\n    device.queue.submit([commandEncoder.finish()]);\n  };\n}\n\nconst glslShaders = {\n  vertex: `#version 450\nlayout(set = 0, binding = 0) uniform Uniforms {\n  mat4 modelMatrix[${numInstances}];\n} uniforms;\n\nlayout(set = 0, binding = 1) uniform CameraMatrix {\n  mat4 viewProjectionMatrix;\n} camera;\n\nlayout(location = 0) in vec4 position;\nlayout(location = 1) in vec4 color;\n\nlayout(location = 0) out vec4 fragColor;\n\nvoid main() {\n  gl_Position = camera.viewProjectionMatrix * uniforms.modelMatrix[gl_InstanceIndex] * position;\n  fragColor = color;\n}\n`,\n\n  fragment: `#version 450\nlayout(location = 0) in vec4 fragColor;\nlayout(location = 0) out vec4 outColor;\n\nvoid main() {\n  outColor = fragColor;\n}\n  `,\n\n  vertexDepthPrePass: `#version 450\nlayout(set = 0, binding = 0) uniform Uniforms {\n  mat4 modelMatrix[${numInstances}];\n} uniforms;\n\nlayout(set = 0, binding = 1) uniform CameraMatrix {\n  mat4 viewProjectionMatrix;\n} camera;\n\nlayout(location = 0) in vec4 position;\n\nvoid main() {\n  gl_Position = camera.viewProjectionMatrix * uniforms.modelMatrix[gl_InstanceIndex] * position;\n}\n`,\n\n  fragmentDepthPrePass: `#version 450\nvoid main() {\n}\n`,\n\n  vertexPrecisionErrorPass: `#version 450\nlayout(set = 0, binding = 0) uniform Uniforms {\n  mat4 modelMatrix[${numInstances}];\n} uniforms;\n\nlayout(set = 0, binding = 1) uniform CameraMatrix {\n  mat4 viewProjectionMatrix;\n} camera;\n\n\nlayout(location = 0) in vec4 position;\n\nlayout(location = 0) out vec4 clipPos;\n\nvoid main() {\n  gl_Position = camera.viewProjectionMatrix * uniforms.modelMatrix[gl_InstanceIndex] * position;\n  clipPos = gl_Position;\n}\n`,\n\n  fragmentPrecisionErrorPass: `#version 450\nlayout(location = 0) in vec4 clipPos;\nlayout(location = 0) out vec4 outColor;\n\nlayout(set = 1, binding = 0) uniform texture2D depthMap;\nlayout(set = 1, binding = 1) uniform sampler depthSampler;\n\nvoid main() {\n  vec2 fragUV = gl_FragCoord.xy / vec2(${kDefaultCanvasWidth.toFixed(\n    1\n  )}, ${kDefaultCanvasHeight.toFixed(1)});\n  float depthValue = texture(sampler2D(depthMap, depthSampler), fragUV).r;\n  float error = abs(clipPos.z / clipPos.w - depthValue);\n  outColor = vec4(vec3(error * 2000000.0), 1.0);\n}\n`,\n\n  vertexTextureQuad: `#version 450\nconst vec2 pos[6] = vec2[6](\n  vec2(-1.0f, -1.0f), vec2(1.0f, -1.0f), vec2(-1.0f, 1.0f),\n  vec2(-1.0f, 1.0f), vec2(1.0f, -1.0f), vec2(1.0f, 1.0f)\n);\nvoid main() {\n  gl_Position = vec4(pos[gl_VertexIndex], 0.0, 1.0);\n}\n  `,\n  fragmentTextureQuad: `#version 450\nlayout(set = 0, binding = 0) uniform texture2D map;\nlayout(set = 0, binding = 1) uniform sampler mapSampler;\n\nlayout(location = 0) out vec4 outColor;\n\nvoid main() {\n  vec2 fragUV = gl_FragCoord.xy / vec2(${kDefaultCanvasWidth.toFixed(\n    1\n  )}, ${kDefaultCanvasHeight.toFixed(1)});\n  float value = texture(sampler2D(map, mapSampler), fragUV).r;\n  outColor = vec4(vec3(value), 1.0);\n}\n  `,\n};\n\nconst wgslShaders = {\n  vertex: `\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(${matrixStride})]] array<mat4x4<f32>, ${numInstances}>;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[builtin(instance_index)]] var<in> instanceIdx : u32;\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[location(0)]] var<in> position : vec4<f32>;\n[[location(1)]] var<in> color : vec4<f32>;\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[location(0)]] var<out> fragColor : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  fragColor = color;\n}\n`,\n  fragment: `\n[[location(0)]] var<in> fragColor : vec4<f32>;\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  outColor = fragColor;\n}\n`,\n  vertexDepthPrePass: `\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(${matrixStride})]] array<mat4x4<f32>, ${numInstances}>;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[builtin(instance_index)]] var<in> instanceIdx : u32;\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[location(0)]] var<in> position : vec4<f32>;\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n}\n`,\n  fragmentDepthPrePass: `\n[[stage(fragment)]]\nfn main() -> void {\n}\n`,\n  vertexPrecisionErrorPass: `\n[[block]] struct Uniforms {\n  modelMatrix : [[stride(${matrixStride})]] array<mat4x4<f32>, ${numInstances}>;\n};\n[[block]] struct Camera {\n  viewProjectionMatrix : mat4x4<f32>;\n};\n\n[[builtin(instance_index)]] var<in> instanceIdx : u32;\n[[binding(0), group(0)]] var<uniform> uniforms : Uniforms;\n[[binding(1), group(0)]] var<uniform> camera : Camera;\n\n[[location(0)]] var<in> position : vec4<f32>;\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[location(0)]] var<out> clipPos : vec4<f32>;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = camera.viewProjectionMatrix * uniforms.modelMatrix[instanceIdx] * position;\n  clipPos = Position;\n}\n`,\n  fragmentPrecisionErrorPass: `\n[[group(1), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(1), binding(1)]] var depthSampler: sampler;\n\n[[location(0)]] var<in> clipPos : vec4<f32>;\n[[builtin(frag_coord)]] var<in> coord : vec4<f32>;\n\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  const depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(${kDefaultCanvasWidth.toFixed(\n    1\n  )}, ${kDefaultCanvasHeight.toFixed(1)})).r;\n  const v : f32 = abs(clipPos.z / clipPos.w - depthValue) * 2000000.0;\n  outColor = vec4<f32>(v, v, v, 1.0) ;\n}\n`,\n  vertexTextureQuad: `\nconst pos : array<vec2<f32>, 6> = array<vec2<f32>, 6>(\n  vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0), vec2<f32>(-1.0, 1.0),\n  vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, -1.0), vec2<f32>(1.0, 1.0));\n\n[[builtin(position)]] var<out> Position : vec4<f32>;\n[[builtin(vertex_index)]] var<in> VertexIndex : u32;\n\n[[stage(vertex)]]\nfn main() -> void {\n  Position = vec4<f32>(pos[VertexIndex], 0.0, 1.0);\n}\n`,\n  fragmentTextureQuad: `\n[[group(0), binding(0)]] var depthTexture: texture_2d<f32>;\n[[group(0), binding(1)]] var depthSampler: sampler;\n\n[[builtin(frag_coord)]] var<in> coord : vec4<f32>;\n[[location(0)]] var<out> outColor : vec4<f32>;\n\n[[stage(fragment)]]\nfn main() -> void {\n  const depthValue : f32 = textureSample(depthTexture, depthSampler, coord.xy / vec2<f32>(${kDefaultCanvasWidth.toFixed(\n    1\n  )}, ${kDefaultCanvasHeight.toFixed(1)})).r;\n  outColor = vec4<f32>(depthValue, depthValue, depthValue, 1.0);\n}\n`,\n};\n\nexport default makeBasicExample({\n  name: 'Reversed Z',\n  description: `This example shows the use of reversed z technique for better utilization of depth buffer precision.\n    The left column uses regular method, while the right one uses reversed z technique.\n    Both are using depth24plus as their depth buffer format. A set of red and green planes are positioned very close to each other.\n    Higher sets are placed further from camera (and are scaled for better visual purpose).\n    To use reversed z to render your scene, you will need depth store value to be 0.0, depth compare function to be greater,\n    and remap depth range by multiplying an additional matrix to your projection matrix.\n    Related reading:\n    https://developer.nvidia.com/content/depth-precision-visualized\n    https://thxforthefish.com/posts/reverse_z/\n    `,\n  slug: 'reversedZ',\n  init,\n  wgslShaders,\n  glslShaders,\n  source: __SOURCE__,\n  gui: true,\n});\n",gui:!0})},XAJ8:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/samples/reversedZ",function(){return t("7r7F")}])}},[["XAJ8",0,1,4,2,3,5]]]);